# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Markus Notti
Student ID: 904269231
Email: 

# Partner 2 (if you're working in a team)
Name: Kyle Baker
Student ID: 604273748
Email: kylebaker37@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
We forked a new process to create a new child. Each child could run task_upload or task_download.
task_upload was the first one to run, then after all the children were spawned, we waited for all the
children to finish. After all the children finished, we forked again and each child ran task_upload.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

One thing I did to fix the buffer overrun problem was that in task_download, we made it so that every time write_from_task_buf is called, it checks the value of t->total_written.
If it is larger than a defined constant of MAX_DL_SIZE, it throws and error, stops the 
download, and checks for other peers to download from.

Another potential buffer overrun we fixed was if the filename requested was too large. We fixed this by using strncpy
to set a max size of the string to copy instead of strcpy.

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

We made it so a made it so if a malicious file hoster tries to serve us a file
that is way too big (i.e. /dev/full) our program catches it and stops downloading.
It does this by using a max file size to make sure it has not downloaded anything
more than that

We also protected against someone trying to send too many connections. We counted
how many connections were coming from a single source and limited them to a max
number of consecuative connections and denied service after that.

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

We implemented 3 different attacks for evil mode.  The first one overloads the filename 
buffer for the peer that is uploading to the evil peer.  When the evil peer requests a
file, it sends a filename which is much longer than the filename size, and therefore when
the good peer gets the message, it should fail.

The second one is just a while (1) loop which, after connecting to a peer, continually
makes requests, so that the peer itâ€™s connected gets hung up by it and cannot do anything else.

The third one is an attack on a peer trying to download by opening dev/full into the 
task disk file descriptor.  This way when the peer tries to download the data from the
file it requested, it instead downloads infinitely from dev/full.


# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.
